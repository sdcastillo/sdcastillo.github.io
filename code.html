<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Code Examples – Futuro Insights</title>
  <meta name="description" content="Code-heavy explorations by Samuel Castillo covering self-improving AI, quantum computing, portfolio wave functions, password hashing, and comparative hardware models for classical and quantum systems.">
  <meta name="keywords" content="Samuel Castillo code, AI code examples, quantum computing code, portfolio as wave function, density matrix, self-improving AI, machine learning, SHA-256, cybersecurity, quantum vs classical computing, Futuro Insights">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <link rel="stylesheet" href="style.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ECY33592SW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}    
    gtag('js', new Date());
    gtag('config', 'G-ECY33592SW');
  </script>
</head>
<body>
  <header>
  <nav class="main-nav">
    <!-- Left side – Personal site -->
    <div class="nav-left">
      <a href="index.html" class="brand">Samuel Castillo</a>
      <a href="about.html">About</a>
      <a href="privacy.html">Privacy</a>
    </div>

    <!-- Right side – Futuro Insights / Products -->
    <div class="nav-right">
      <a href="index.html">Futuro Home</a>
      <a href="code.html">Code</a>
      <a href="studymanual.html">Study Manual</a>
      <a href="buy.html" class="buy-cta">BUY</a>
      <a href="contact.html">Contact</a>
      <a href="returns.html">Returns</a>
    </div>

    <!-- Mobile menu button -->
    <button class="nav-toggle" aria-label="Menu">Menu</button>
  </nav>
</header>



  <main>

    


    <h1>Code that writes code</h1>
    <p>Exponential-looking growth in computing emerges when systems can improve their own code. Once a loop exists that can generate, execute, measure, and refine programs, capability compounds: each improvement enhances the next round of search over the program phase space. The driver is not just device density, but a feedback process that compresses errors, increases information flow, and reduces effective entropy in the distribution of behaviors.</p>
    <p>
      In mathematical terms, let the capability at iteration \(t\) be \(C(t)\). A simple model of compounded self-improvement is
      \[
        C(t+1) = (1 + r)\,C(t), \qquad r > 0,
      \]
      whose solution is
      \[
        C(t) = C(0)\,(1 + r)^t \approx C(0)\,e^{rt},
      \]
      capturing the "exponential-looking" growth. A more general continuous-time feedback model writes
      \[
        \frac{dC}{dt} = f(I,C,E),
      \]
      where \(I\) measures information flow through the system and \(E\) is the average error. A negative dependence \(\partial f/\partial E < 0\) and positive \(\partial f/\partial I > 0\) encode that reducing errors and increasing information flow accelerates capability.
    </p>
    <p>
      Let the program hypothesis space be a high-dimensional manifold \(\mathcal{H}\) with coordinates \(\theta \in \mathbb{R}^d\) parameterizing programs, and let a loss (or energy-like) function be \(L : \mathcal{H} \to \mathbb{R}_+\). Guided search corresponds to iterates
      \[
        \theta_{t+1} = \theta_t - \eta_t \, \nabla_\theta L(\theta_t) + \xi_t,
      \]
      where \(\eta_t\) is a learning rate and \(\xi_t\) represents stochastic exploration. The associated probability density over programs, \(p_t(\theta)\), can be modeled as a Gibbs-like distribution
      \[
        p_t(\theta) = \frac{1}{Z_t} \exp\big(-\beta_t L(\theta)\big),
      \]
      with partition function \(Z_t\) and inverse temperature \(\beta_t\) reflecting how strongly the system prefers lower-loss code. As \(t\) increases and \(\beta_t\) grows, the distribution contracts around high-quality programs, reducing effective entropy
      \[
        S[p_t] = - \int_{\mathcal{H}} p_t(\theta)\, \log p_t(\theta)\, d\theta.
      \]
    </p>

    <h2>Mechanism of self-improvement (physics and information terms)</h2>
    <ul>
      <li>Program synthesis as guided search over a high-dimensional landscape; gradients, heuristics, and discrete exploration move candidates toward lower loss (energy-like objective).</li>
    </ul>
    <p>
      Formally, represent each candidate program by parameters \(\theta \in \mathbb{R}^d\) and define an objective (loss/energy) \(L(\theta)\). Gradient-based guidance is
      \[
        \theta_{t+1} = \theta_t - \eta_t \, \nabla_\theta L(\theta_t),
      \]
      while purely heuristic or discrete search can be modeled by a Markov chain with transition kernel \(K(\theta'\mid\theta)\) that satisfies
      \[
        p_{t+1}(\theta') = \int K(\theta'\mid\theta)\,p_t(\theta)\,d\theta,
      \]
      where \(p_t(\theta)\) is the probability density over program parameters at iteration \(t\). The stationary distribution \(p_*(\theta)\) often approximates a Boltzmann form \(p_*(\theta) \propto e^{-\beta L(\theta)}\), concentrating mass near minima of \(L\).
    </p>
    <ul>
      <li>Error-correcting feedback reduces uncertainty: observations act as measurements that collapse hypotheses, concentrating probability mass on higher-fidelity code.</li>
    </ul>
    <p>
      Let \(\Theta\) be a discrete hypothesis set of programs, with prior \(P(\theta)\) for \(\theta \in \Theta\). Given observed data or test outcomes \(D\), Bayes' rule updates beliefs via
      \[
        P(\theta \mid D) = \frac{P(D \mid \theta)P(\theta)}{P(D)}, \qquad P(D) = \sum_{\theta' \in \Theta} P(D \mid \theta')P(\theta').
      \]
      The Shannon entropy of the hypothesis distribution is
      \[
        H[P] = -\sum_{\theta \in \Theta} P(\theta)\,\log P(\theta).
      \]
      Error-correcting feedback corresponds to sequences of measurements \(D_1, D_2, \dots\) such that
      \[
        H\big[P(\cdot \mid D_1,\dots,D_t)\big] \searrow H_* \quad \text{as} \quad t \to \infty,
      \]
      where \(H_*\) is low and the posterior probability mass is concentrated on a small set of high-fidelity programs.
    </p>
    <ul>
      <li>Thermodynamics of computation: every irreversible operation dissipates energy; efficient self-editing favors representations and compilers that minimize erasures while maximizing useful work per joule.</li>
    </ul>
    <p>
      Landauer's principle states that erasing one bit of information incurs a minimum heat dissipation
      \[
        Q_{\min} = k_B T \ln 2,
      \]
      where \(k_B\) is Boltzmann's constant and \(T\) is the ambient temperature. If a self-editing system performs \(N_\text{erase}\) bit erasures per update, the minimal thermodynamic cost per update is
      \[
        Q_\text{update} \ge N_\text{erase}\,k_B T \ln 2.
      \]
      The computational efficiency can be expressed as useful information gain per unit energy,
      \[
        \eta_\text{info} = \frac{\Delta I}{Q_\text{update}},
      \]
      where \(\Delta I\) is the increase in mutual information between internal model parameters \(\Theta\) and task outcomes \(Y\):
      \[
        I(\Theta;Y) = \sum_{\theta,y} p(\theta,y)\, \log \frac{p(\theta,y)}{p(\theta)\,p(y)}.
      \]
      Efficient self-editing corresponds to strategies that maximize \(\eta_\text{info}\) by minimizing unnecessary erasures and maximizing \(\Delta I\).
    </p>
    <ul>
      <li>Compression and generalization: shorter effective descriptions (lower algorithmic complexity) tend to transfer across tasks, enabling accelerated reuse and faster convergence on new problems.</li>
    </ul>
    <p>
      Let the Kolmogorov complexity (algorithmic information content) of a solution for task \(T\) be \(K(T)\), defined as the length (in bits) of the shortest program that solves \(T\) on a fixed universal Turing machine \(U\). For two tasks \(T_1, T_2\), the shared structure can be quantified by an information-theoretic overlap
      \[
        I(T_1;T_2) \approx K(T_1) + K(T_2) - K(T_1,T_2),
      \]
      where \(K(T_1,T_2)\) is the complexity of jointly solving both tasks. Reusable compressed representations correspond to internal codes \(z\) of small description length \(L(z)\) that minimize expected description length over tasks:
      \[
        \min_{z} \, \mathbb{E}_{T \sim \mathcal{D}}\big[ L(z) + L(T \mid z) \big],
      \]
      with \(\mathcal{D}\) a task distribution. Lower \(L(z)\) and \(L(T\mid z)\) imply faster adaptation and thus accelerated convergence on new problems.
    </p>

    <h2>How this page is assembled</h2>
    <p>This page was assembled with automated assistance: generative tooling produced structure and text, which were reviewed and emitted as static HTML. In other words, the site itself serves as a small example of code that helps author more code. AI for Not Bad.</p>
    <p>
      Abstractly, denote the human editor as \(H\) and the generative model as \(G\). Let \(x\) be an initial specification and \(y\) the final HTML. The interaction can be seen as an alternating minimization over drafts \(y_t\):
      \[
        y_{t+1} = \operatorname*{arg\,min}_{y} 
          \Big( \mathcal{L}_\text{spec}(y \mid x) + \mathcal{L}_\text{style}(y) + \mathcal{L}_\text{error}(y) \Big),
      \]
      with updates produced by either \(G\) or \(H\):
      \[
        y_{t+1} =
        \begin{cases}
          G(y_t,x,\xi_t) & \text{with probability } p_G, \\
          H(y_t,x) & \text{with probability } 1-p_G,
        \end{cases}
      \]
      where \(\xi_t\) captures model stochasticity. Convergence is reached when successive edits satisfy a small-difference condition, e.g.
      \[
        d(y_{t+1},y_t) < \varepsilon,
      \]
      for a suitable distance metric \(d\) on documents.
    </p>

    <h2>Minimal meta-programming sketch</h2>
    <pre><code>// Pseudocode for a self-improving loop
population = initialize_programs()
while (time &lt; budget):
  for prog in population:
    result = execute(prog, tests)
    score  = measure(result)
    log(result, score)
  models = fit_surrogates(log)          // learn to predict score from program features
  proposals = propose(models)           // synthesize or mutate new programs
  population = select(population, proposals, log) // keep better, diverse candidates
  if converged(population): break
deploy(best(population))
</code></pre>
    <p>
      Let the population at iteration \(t\) be \(\mathcal{P}_t = \{\theta_t^{(1)},\dots,\theta_t^{(N)}\}\), and let each candidate have a score (fitness) \(F(\theta)\). The selection step can be modeled by a softmax (Boltzmann) sampling distribution
      \[
        P_t(\theta) = \frac{\exp\big(\beta_t F(\theta)\big)}{\sum_{\theta' \in \mathcal{P}_t} \exp\big(\beta_t F(\theta')\big)},
      \]
      with inverse temperature \(\beta_t\) controlling selection pressure. Proposals (mutations or synthesized programs) \(\tilde{\theta}\) are drawn from a proposal kernel \(q_t(\tilde{\theta} \mid \theta)\), so the expected update of the population distribution is
      \[
        p_{t+1}(\tilde{\theta}) = \sum_{\theta} P_t(\theta)\, q_t(\tilde{\theta} \mid \theta).
      \]
      Convergence of the loop can be expressed via a stopping condition such as
      \[
        \operatorname{Var}_{\theta \sim p_t}[F(\theta)] < \delta
        \quad \text{or} \quad
        \max_{\theta \in \mathcal{P}_t} F(\theta) - \max_{\theta \in \mathcal{P}_{t-k}} F(\theta) < \epsilon,
      \]
      for some window size \(k\) and tolerances \(\delta, \epsilon\).
    </p>

    <h2>Hierarchical graph of matter and interactions</h2>
    <pre>Universe
└─ Quantum fields
   ├─ Fermion fields (matter)
   │  ├─ Quarks (color charge: red/green/blue)
   │  │  ├─ Flavors: up, down, charm, strange, top, bottom
   │  │  └─ Bound states (hadrons)
   │  │     ├─ Baryons (3 quarks)
   │  │     │  ├─ Proton: u u d
   │  │     │  ├─ Neutron: u d d
   │  │     │  └─ Antibaryons (3 antiquarks)
   │  │     │     └─ Antiproton: ū ū d̄
   │  │     └─ Mesons (quark + antiquark)
   │  └─ Leptons
   │     ├─ Electron, Muon, Tau
   │     └─ Neutrinos (three types) + corresponding antiparticles (e.g., positron)
   ├─ Boson fields (interaction carriers)
   │  ├─ Gluons (strong interaction, SU(3) color)
   │  ├─ Photon (electromagnetic, U(1))
   │  ├─ W± and Z⁰ (weak interaction)
   │  └─ Gravitational quantum (graviton, hypothetical)
   └─ Scalar field associated with electroweak symmetry breaking
      └─ Scalar boson (mass-generating excitation)

Composite structures
└─ Atomic nucleus: protons + neutrons (held by residual strong force)
   ├─ Atoms: nucleus + electron cloud (quantized orbitals)
   ├─ Molecules: atoms bound via electromagnetic interaction
   └─ Condensed phases: solids, liquids, gases, plasmas, exotic matter
</pre>
    <p>“Matter” typically denotes fermions and their composites. Gauge bosons (such as gluons) mediate interactions and are included for completeness.</p>
    <p>
      In the Standard Model, the fundamental fields can be written as a Lagrangian density \(\mathcal{L}_\text{SM}\) of the form
      \[
        \mathcal{L}_\text{SM} = -\frac{1}{4} \sum_{a} F_{\mu\nu}^a F^{a\,\mu\nu}
        + \sum_{f} \bar{\psi}_f\big(i\gamma^\mu D_\mu - m_f\big)\psi_f
        + (D_\mu \phi)^\dagger(D^\mu \phi) - V(\phi)
        + \mathcal{L}_\text{Yukawa},
      \]
      where
      \
        F_{\mu\nu}^a = \partial_\mu A_\nu^a - \partial_\nu A_\mu^a + g f^{abc} A_\mu^b A_\nu^c
      \\
      encodes the gauge bosons (gluons, \(W^\pm, Z^0\), photon), \(\psi_f\) are fermion fields (quarks and leptons), \(\phi\) is the Higgs scalar field, and
      \(D_\mu = \partial_\mu - i g A_\mu^a T^a\) is the gauge-covariant derivative.
    </p>
    <p>
      Color-charged quarks \(q\) interact via the SU(3) gauge field \(G_\mu^a\) with coupling constant \(g_s\), described by
      \[
        \mathcal{L}_\text{QCD} = \bar{q}\big(i\gamma^\mu D_\mu - m_q\big)q - \frac{1}{4} G_{\mu\nu}^a G^{a\,\mu\nu},
      \]
      where \(D_\mu = \partial_\mu - i g_s T^a G_\mu^a\) and \(G_{\mu\nu}^a\) has the same non-Abelian structure as \(F_{\mu\nu}^a\) above. Bound states such as protons and neutrons are color-singlet combinations of three quarks (baryons), while mesons are quark–antiquark pairs \(q \bar{q}\), consistent with overall color neutrality.
    </p>
    <p>
      Leptons (electron \(e\), muon \(\mu\), tau \(\tau\) and their neutrinos \(\nu_e, \nu_\mu, \nu_\tau\)) couple to the electroweak SU(2)\(_L\)\timesU(1)\(_Y\) gauge fields. After electroweak symmetry breaking, the Higgs field acquires a vacuum expectation value
      \[
        \langle \phi \rangle = \frac{1}{\sqrt{2}} \begin{pmatrix}0 \\ v \end{pmatrix}, \qquad v \approx 246~\text{GeV},
      \]
      which generates fermion and weak boson masses through Yukawa terms \(y_f \bar{\psi}_f \phi \psi_f\) and gauge interactions, while leaving the photon massless.
    </p>
    <p>
      Composite structures are organized hierarchically. A nucleus with \(Z\) protons and \(A-Z\) neutrons has baryon number \(B = A\) and charge \(Q = Z e\). An atom adds \(Z\) electrons, leading to a many-body Hamiltonian
      \[
        H = \sum_{i=1}^{Z} \bigg( -\frac{\hbar^2}{2m_e} \nabla_i^2 - \frac{Z e^2}{4\pi \varepsilon_0 r_i} \bigg)
          + \sum_{1 \le i < j \le Z} \frac{e^2}{4\pi \varepsilon_0 \lvert \mathbf{r}_i - \mathbf{r}_j \rvert}
          + H_\text{nucleus},
      \]
      whose eigenstates \(\Psi_n\) correspond to quantized orbitals and energy levels \(E_n\) solving
      \[
        H \Psi_n = E_n \Psi_n.
      \]
      Molecules and condensed phases arise when these atomic states combine via electromagnetic interactions into multi-atom bound states and extended many-body systems.
    </p>

    <section>
      <h2>Portfolio as a wave function: density matrices instead of variance–covariance matrices</h2>
      <p>Below is a compact, code-adjacent sketch of the idea: in a quantum-flavored actuarial / MPT model, the classical variance–covariance matrix \(\Sigma\) is upgraded to a density matrix \(\rho\), and a portfolio is treated as a wave function \(|\psi\rangle\). This mirrors what you might simulate with Stan, but in linear-algebra form.</p>

      <h3>Classical MPT / actuarial notation</h3>
      <pre><code>// n assets, vector of random returns R
// mean vector μ, variance–covariance matrix Σ

E[R]   = μ               // n×1
Cov(R) = Σ               // n×n (symmetric, PSD)

// portfolio weights (deterministic)
vector[n] w;
real R_p = dot_product(w, R);     // portfolio return

real mean_p   = dot_product(w, μ);
real var_p    = quad_form(Σ, w);  // w^T Σ w
</code></pre>
      <p><em>LaTeX form:</em> \( \mathbb{E}[R] = \mu \), \( \operatorname{Cov}(R) = \Sigma \), \( R_p = w^\top R \), \( \mathbb{E}[R_p] = w^\top \mu \), \( \operatorname{Var}(R_p) = w^\top \Sigma w \).</p>

      <h3>Quantum-style upgrade</h3>
      <p>We now re-interpret these same objects in a Hilbert-space way:</p>
      <ul>
        <li>Basis states \(|e_i\rangle\): one-hot exposure to asset \(i\).</li>
        <li>Portfolio wave function \(|\psi\rangle = \sum_i \psi_i |e_i\rangle\) with \(\sum_i |\psi_i|^2 = 1\).</li>
        <li>Density matrix (pure state) \(\rho = |\psi\rangle\langle\psi|\).</li>
        <li>Return operator \(\hat R\) with components \(\hat R |e_i\rangle = R_i |e_i\rangle\) in the simplest diagonal case.</li>
      </ul>
      <p>In code-flavored pseudomath:</p>
      <pre><code>// amplitudes ψ (complex allowed), normalized
complex psi[n];
// density matrix ρ_ij = ψ_i ψ*_j
complex rho[n, n] = outer_product(psi, conj(psi));

// return operator R̂ (for illustration, take it diagonal)
real R_vals[n];    // possible asset returns
complex R_op[n, n];
for (i in 1:n) {
  for (j in 1:n) R_op[i,j] = (i == j) ? R_vals[i] : 0;
}

// quantum expectation of portfolio return
complex mean_p_q = trace(rho * R_op); // &approx; classical w^T μ
</code></pre>
      <p>Mathematically,</p>
      <pre>ρ = |ψ><ψ|
&lt;R̂>_ψ = &lt;ψ| R̂ |ψ> = Tr(ρ R̂)</pre>
      <p><em>LaTeX form:</em> \( \rho = |\psi\rangle\langle\psi| \), \( \langle \hat R \rangle_\psi = \langle \psi|\hat R|\psi\rangle = \operatorname{Tr}(\rho \hat R) \).</p>
      <p>If \(\hat R\) is diagonal in the \(|e_i\rangle\) basis and we ignore phases, \(|\psi_i|^2\) plays the same role as classical weights \(w_i\). But once off-diagonal elements are allowed, \(\rho\) carries richer cross-asset structure than \(\Sigma\) alone.</p>

      <h3>Stan-style simulation vs Schrödinger-style evolution</h3>
      <p>Stan would typically simulate posterior draws of parameters \(\theta\) (e.g., drifts, vols, correlations) and then simulate returns:</p>
      <pre><code>// very schematic Stan pseudo-flow
for (m in 1:M) {
  θ[m] ~ posterior(· | data);      // parameters: μ[m], Σ[m], etc.
  R[m] ~ mvnormal(μ[m], Σ[m]);     // draw returns
  R_p[m] = dot_product(w, R[m]);
}
// compute empirical mean/var/VaR of R_p from samples
</code></pre>
      <p>In the wave-function view, instead of sampling many \(\theta\), we evolve the state itself under a Hamiltonian \(\hat H\) that encodes drift/volatility/market structure:</p>
      <pre><code>// time evolution of portfolio state ψ_t
// i ℏ d|ψ_t>/dt = Ĥ |ψ_t>

psi_t+Δt ≈ exp(-i Δt Ĥ / ℏ) * psi_t;

// at horizon T, density matrix ρ_T = |ψ_T><ψ_T|
// expected payoff under operator Π̂
price_0 ≈ discount * trace(ρ_T * Π̂);
</code></pre>
      <p>This is the code-level version of “instead of running Stan simulations over parameter space, we let the whole portfolio turn into a wave function and flow under \(\hat H\).”</p>

      <h3>Black–Scholes as the one-asset limit</h3>
      <p>For a single risky asset in Black–Scholes, under the risk-neutral measure we have</p>
      <pre>dS_t = r S_t dt + σ S_t dW_t</pre>
      <p>The price \(V(S,t)\) of a European claim satisfies</p>
      <pre>∂V/∂t + (1/2) σ^2 S^2 ∂^2V/∂S^2 + r S ∂V/∂S - r V = 0</pre>
      <p>After changing variables \(x = \ln S\) and switching to forward time \(τ = T - t\), this maps to a heat equation which can be written in imaginary time as</p>
      <pre>∂φ/∂τ = (1/2) σ^2 ∂^2φ/∂x^2 - V_eff(x) φ</pre>
      <p>Under a Wick rotation \(τ → i t\), this resembles a Schrödinger equation</p>
      <pre>i ℏ ∂ψ/∂t = Ĥ ψ</pre>
      <p>with \(\hat H\) containing a kinetic term (diffusion from \(σ\)) plus an effective potential. In this limit:</p>
      <ul>
        <li>Classical risk-neutral density \(f_{S_T}(s)\) ↔ \(|\psi(s,T)|^2\).</li>
        <li>Option price \(V_0\) ↔ expectation \(\langle \psi_T| \hat \Pi |\psi_T\rangle\).</li>
      </ul>
      <p>So Black–Scholes is already half-way to the quantum formalism: it evolves distributions through a linear PDE. The density-matrix formulation just generalizes this to multiple coupled assets and richer dependence than a single \(\Sigma\) can conveniently express.</p>
    </section>

    <section>
      
<table>
  <thead>
    <tr>
      <th>Rank</th>
      <th>System Name</th>
      <th>Developer</th>
      <th>Qubit Type</th>
      <th>Physical Qubits</th>
      <th>Key Performance Metrics</th>
      <th>Notable Achievements</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="rank">1</td>
      <td>System Model H2</td>
      <td>Quantinuum</td>
      <td>Trapped Ion</td>
      <td>32+ (scalable to 56)</td>
      <td>QV: 2²⁵ (33,554,432); 2-qubit fidelity: 99.9% ("three 9s"); Logical qubits: Up to 12 entangled with 0.0011% error rate</td>
      <td>World's highest QV; 4× QV gain in 2025 alone; First chemistry sim combining QC, HPC, and AI; Outperforms all in stable, fault-tolerant ops.</td>
    </tr>
    <tr>
      <td class="rank">2</td>
      <td>Willow</td>
      <td>Google Quantum AI</td>
      <td>Superconducting</td>
      <td>105</td>
      <td>2-qubit fidelity: >99.9%; Performs RCS benchmark in <5 min (10²⁵ years classically); Logical qubits: Demonstrated below-threshold error correction</td>
      <td>Quantum supremacy on practical tasks; Doubles coherence vs. physical qubits; Outpaces supercomputers by 10 septillion times on sampling.</td>
    </tr>
    <tr>
      <td class="rank">3</td>
      <td>Zuchongzhi 3.0</td>
      <td>USTC (China)</td>
      <td>Superconducting</td>
      <td>105</td>
      <td>1-qubit fidelity: 99.90%; 2-qubit fidelity: 99.62%; Task speed: Seconds (5.9B years classically)</td>
      <td>Rivals Willow in speed; Uses low-noise tantalum/niobium; 15×7 lattice for high connectivity; Major leap in raw performance.</td>
    </tr>
    <tr>
      <td class="rank">4</td>
      <td>Nighthawk</td>
      <td>IBM</td>
      <td>Superconducting</td>
      <td>120</td>
      <td>Up to 5,000 two-qubit gates; 2-qubit fidelity: ~99.5%; QV: >2²⁰ (est.); Tunable couplers: 218+</td>
      <td>Path to 2026 quantum advantage; 20% more couplers than Heron; Real-time error decoding in <480 ns; Utility-scale molecular sims with Fugaku supercomputer.</td>
    </tr>
    <tr>
      <td class="rank">5</td>
      <td>Forte Enterprise</td>
      <td>IonQ</td>
      <td>Trapped Ion</td>
      <td>36 (Tempo: 64 planned)</td>
      <td>2-qubit fidelity: 99.99% ("four 9s"); #AQ 36 (all-to-all connectivity); 20× performance gains in apps</td>
      <td>World-record fidelity for error correction; Efficient logical qubits with fewer physical ones; Used in drug discovery and finance modeling.</td>
    </tr>
    <tr>
      <td class="rank">6</td>
      <td>Ankaa-3</td>
      <td>Rigetti</td>
      <td>Superconducting</td>
      <td>84+ (100+ modular by end-2025)</td>
      <td>2-qubit fidelity: 99.5%; Nanosecond gate speeds; Real-time error correction on 84 qubits</td>
      <td>Fastest gate times (vs. microsecond rivals); Sold as QPUs to labs; Chiplet roadmap for utility-scale; 98% median fidelity in square lattice.</td>
    </tr>
    <tr>
      <td class="rank">7</td>
      <td>Neutral Atom Array</td>
      <td>QuEra Computing</td>
      <td>Neutral Atom</td>
      <td>3,000 (planned; current: 256)</td>
      <td>Logical qubits: 48 with 0.5% error (vs. IBM's 2.9%); High entanglement stability</td>
      <td>Fault-tolerant leader; Outperforms Heron in error rates; Scales to 10,000 qubits by 2026; Apps in logistics and materials science.</td>
    </tr>
    <tr>
      <td class="rank">8</td>
      <td>Majorana 1</td>
      <td>Microsoft (Azure Quantum)</td>
      <td>Topological</td>
      <td>~24 logical (scalable to 1M)</td>
      <td>Inherent low error rates; High-fidelity Majorana quasiparticles; Logical qubits: 12+ entangled</td>
      <td>First topological processor; Million-qubit potential; Integrates with Quantinuum/Atom for chemistry/AI; Below-threshold errors.</td>
    </tr>
    <tr>
      <td class="rank">9</td>
      <td>Advantage 2</td>
      <td>D-Wave</td>
      <td>Quantum Annealing</td>
      <td>7,440</td>
      <td>15-way connectivity; Quantum supremacy on real-world optimization</td>
      <td>Fastest for optimization (e.g., logistics); Not gate-based, but 3-month free trials via Leap; Beats classical on QUBO problems.</td>
    </tr>
    <tr>
      <td class="rank">10</td>
      <td>Kookaburra</td>
      <td>IBM</td>
      <td>Superconducting</td>
      <td>1,386 (multi-chip)</td>
      <td>Enhanced coherence; High gate fidelity (~99%); Part of Heron R2 upgrades</td>
      <td>Massive scale for 2025; Builds on Condor (1,121 qubits); Focus on error-corrected simulations; Quantum-centric supercomputing.</td>
    </tr>
  </tbody>
</table>

    </section>


    <section>
      <h2>Classical vs Quantum Computer: pseudo-code views</h2>
      <p>This section strips away hardware details and shows, in pseudo‑code, how a conventional laptop and a quantum processor “feel” different as machines.</p>

      <h3>Conventional computer (motherboard + CPU + RAM)</h3>
      <pre><code>// physical picture
// --------------------------------------------------
// motherboard: connects CPU, RAM, storage, peripherals
// CPU: executes instructions sequentially (with some parallelism)
// RAM: holds bits (0 or 1) for active programs

machine ClassicalComputer {
  Motherboard board;
  CPU         cpu;
  RAM         ram;
  Storage     disk;
}

// run a program
function run_classical(program P, input bits_in[]):
  // 1. load code and data into RAM
  ram.load(P.code)
  ram.load(bits_in)

  // 2. CPU executes instructions one by one
  while cpu.instruction_pointer not at END(P):
    instr = ram.fetch(cpu.instruction_pointer)
    cpu.execute(instr, ram)
    cpu.instruction_pointer++

  // 3. read out output bits from RAM
  bits_out = ram.read(P.output_region)
  return bits_out
</code></pre>

      <h3>Quantum processor (QPU + classical control computer)</h3>
      <pre><code>// physical picture
// --------------------------------------------------
// classical control computer: compiles code, sends pulses
// quantum processing unit (QPU): array of qubits on a chip
// cryostat: keeps QPU near absolute zero

machine QuantumComputer {
  ClassicalControl ctrl;     // compiler, schedulers
  QuantumProcessingUnit qpu; // qubits + control lines
}

// high-level quantum run
function run_quantum(circuit C, classical_input bits_in[]):
  // 1. classical pre-processing
  //    e.g., encode bits_in into initial qubit states
  compiled_pulses = ctrl.compile(C, bits_in)

  // 2. upload pulse schedule to QPU
  qpu.load(compiled_pulses)

  // 3. apply quantum operations (unitaries)
  qpu.apply_pulses()
  // internally, each gate is a unitary U on |ψ>:
  //    |ψ_new> = U |ψ_old>

  // 4. measure qubits
  measurement_record = qpu.measure_all() // collapses |ψ> → classical bits

  // 5. classical post-processing
  result = ctrl.post_process(measurement_record)
  return result
</code></pre>

      <p>Conceptually:</p>
      <ul>
        <li>The <strong>classical CPU</strong> walks through a list of instructions, flipping bits in RAM.</li>
        <li>The <strong>QPU</strong> evolves a joint quantum state \(|\psi\rangle\) of many qubits by applying gates (unitaries), then collapses that state to classical bits via measurement.</li>
      </ul>

      <h3>Same abstract computation, two execution models</h3>
      <p>Imagine we want to compute the parity (even/odd) of \(N\) bits.</p>

      <h4>Classical laptop parity</h4>
      <pre><code>function parity_classical(bits[]):
  acc = 0
  for b in bits:
    acc = acc XOR b
  return acc  // 0 = even, 1 = odd
</code></pre>

      <h4>Quantum parity sketch (conceptual)</h4>
      <pre><code>function parity_quantum(bits[]):
  // 1. encode bits into computational basis states
  //    |b_1 b_2 ... b_N>
  |ψ> = |b_1 b_2 ... b_N>

  // 2. use a circuit of CNOTs to copy global parity into an ancilla qubit
  //    |ψ, 0>  →  |ψ, parity(bits)>
  for i in 1..N:
    CNOT(control = qubit_i, target = ancilla)

  // 3. measure only the ancilla qubit
  result = measure(ancilla)
  return result  // 0 = even, 1 = odd
</code></pre>
      <p>On such a small task, the quantum route is not “better” than the classical one—it is just a different physical implementation of the same logical function. Real quantum advantage typically appears in problems that exploit superposition and interference over huge state spaces.</p>
    </section>

    <section>
      <h2>Hardware analogy table: consumer laptop vs quantum processor</h2>
      <p>The numbers below are intentionally rounded, order‑of‑magnitude style, to give intuition. Real devices vary wildly; treat these as cartoon benchmarks, not spec sheets.</p>

      <table border="1" cellpadding="4" cellspacing="0">
        <thead>
          <tr>
            <th>Device</th>
            <th>Rough scale</th>
            <th>Operation type</th>
            <th>Throughput (back‑of‑envelope)</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Consumer laptop CPU (1 core)</td>
            <td>~3 GHz clock</td>
            <td>Classical bit ops</td>
            <td>~3×10<sup>9</sup> simple ops/s</td>
            <td>One scalar instruction stream; vector units add more parallelism.</td>
          </tr>
          <tr>
            <td>Consumer laptop (8 cores, SIMD)</td>
            <td>8 cores × 3 GHz × 128‑bit SIMD</td>
            <td>Classical bit/word ops</td>
            <td>~10<sup>11</sup>–10<sup>12</sup> basic ops/s</td>
            <td>Depends heavily on workload and vectorization.</td>
          </tr>
          <tr>
            <td>Mid‑range GPU in a laptop</td>
            <td>~10<sup>3</sup>–10<sup>4</sup> cores</td>
            <td>Classical float ops</td>
            <td>~10<sup>12</sup>–10<sup>13</sup> FLOP/s peak</td>
            <td>Great for dense linear algebra and ML training.</td>
          </tr>
          <tr>
            <td>Small noisy quantum processor</td>
            <td>~50–100 physical qubits</td>
            <td>Quantum gates on 2<sup>N</sup>-dim state</td>
            <td>~10<sup>3</sup>–10<sup>4</sup> 2‑qubit gates per run before noise</td>
            <td>Each gate acts on amplitudes of 2<sup>N</sup> basis states in superposition.</td>
          </tr>
          <tr>
            <td>Hypothetical fault‑tolerant QPU</td>
            <td>~10<sup>6</sup> physical qubits → 10<sup>3</sup> logical</td>
            <td>Error‑corrected quantum circuits</td>
            <td>~10<sup>9</sup>–10<sup>12</sup> logical gates over long algorithms</td>
            <td>Aimed at large chemistry, optimization, or cryptographic tasks.</td>
          </tr>
        </tbody>
      </table>

      <h3>"How many laptops equal one quantum processor?" (cartoon answers)</h3>
      <p>The trick is: you cannot fairly compare them just by counting operations per second, because a quantum gate on \(N\) qubits simultaneously transforms amplitudes across \(2^N\) basis states. Still, you can get a feeling by asking:</p>

      <h4>Example 1: simulating 30 qubits on laptops</h4>
      <ul>
        <li>State vector size: \(2^{30} \approx 10^9\) complex amplitudes.</li>
        <li>One layer of single‑qubit gates might touch all \(10^9\) amplitudes.</li>
        <li>A single good laptop GPU at ~10<sup>12</sup> FLOP/s can simulate ~10<sup>3</sup> such layers per second <em>in theory</em>, but memory bandwidth and overhead reduce this a lot.</li>
      </ul>
      <p>A small physical QPU with 30–40 qubits applies the same logical layer <em>directly in hardware</em>; it is as if you had a cluster of hundreds to thousands of laptops working together to update all amplitudes every gate.</p>

      <h4>Example 2: 50‑qubit state</h4>
      <ul>
        <li>State vector size: \(2^{50} \approx 10^{15}\) complex amplitudes.</li>
        <li>Storing this naively (16 bytes per complex) needs ~16 petabytes of RAM.</li>
        <li>Even a supercomputer cluster of millions of consumer‑class laptops would struggle to hold and update this in full generality.</li>
      </ul>
      <p>So for <strong>generic</strong> 50‑qubit circuits, one real QPU is morally comparable to an enormous classical cluster. For <strong>structured</strong> problems, clever classical algorithms can do much better—that’s why the “how many laptops” question has no single honest number.</p>

      <h3>Very rough equivalence table (for mental models only)</h3>
      <table border="1" cellpadding="4" cellspacing="0">
        <thead>
          <tr>
            <th>Quantum device (noisy)</th>
            <th>State size 2<sup>N</sup></th>
            <th>Naive RAM to store state</th>
            <th>Approx. # of 16 GB laptops for RAM only</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>20‑qubit QPU</td>
            <td>~10<sup>6</sup></td>
            <td>~16 MB</td>
            <td>&lt; 1 laptop (fits easily)</td>
          </tr>
          <tr>
            <td>30‑qubit QPU</td>
            <td>~10<sup>9</sup></td>
            <td>~16 GB</td>
            <td>~1 laptop (RAM is tight but possible)</td>
          </tr>
          <tr>
            <td>40‑qubit QPU</td>
            <td>~10<sup>12</sup></td>
            <td>~16 TB</td>
            <td>~1000 laptops (each 16 GB)</td>
          </tr>
          <tr>
            <td>50‑qubit QPU</td>
            <td>~10<sup>15</sup></td>
            <td>~16 PB</td>
            <td>~1,000,000 laptops (each 16 GB)</td>
          </tr>
        </tbody>
      </table>
      <p>This table only matches <em>memory</em> capacity, not speed. But it gives a rough intuition: once you pass ~40–50 entangled qubits in a generic circuit, brute‑force classical simulation starts looking like “you’d need an absurd number of consumer laptops.”</p>
    </section>

    <section>
      <h2>SHA-256 password hashing examples</h2>
      <p>The table below shows a few simple example passwords and their corresponding SHA-256 hash values. These are illustrative only; never hard‑code real passwords or reuse simple patterns like these in production.</p>
      <table border="1" cellpadding="4" cellspacing="0">
        <thead>
          <tr>
            <th>Example password</th>
            <th>SHA-256 hash (hex)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>password</td>
            <td>5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8</td>
          </tr>
          <tr>
            <td>123456</td>
            <td>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</td>
          </tr>
          <tr>
            <td>correcthorsebatterystaple</td>
            <td>cbe6beb26479b568e5f15b50217c6c83c0ee051dc4e522b9840d8e291d6aaf46</td>
          </tr>
          <tr>
            <td>QuantumR0cks!</td>
            <td>a7c2a1b4b785bb7b39d6b26bafdc6f919aa0cc47a18eb2f6559bf0369a671a7a</td>
          </tr>
        </tbody>
      </table>
      <p style="margin-top:0.75rem; font-size:0.9em;">
        Hashes above were computed with standard SHA-256; you can reproduce them using tools like <code>sha256sum</code>, <code>openssl dgst -sha256</code>, Python’s <code>hashlib.sha256</code>, or any reputable online hash calculator.
      </p>
    </section>

    <!-- BEGIN: Added password cracking / MFA table and explanation -->
    <section>
      <h2>How long would it take to crack these passwords?</h2>
      <p>The table below uses deliberately rough, order‑of‑magnitude estimates to show how different passwords fare against brute‑force search on classical hardware and on a future, optimistic quantum attacker using Grover-style speedups. The point is not the exact numbers, but the contrast between weak and strong secrets—and why multi‑factor authentication (MFA) is so valuable.</p>

      <style>
        
    table {
      width: 100%;
      max-width: 1400px;
      border-collapse: separate;
      border-spacing: 0;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      background: #4682b4; /* steelblue */
    }
    thead th {
      background: #2c5d80;
      color: white;
      padding: 16px 12px;
      text-align: left;
      font-weight: 600;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    tbody tr:nth-child(odd) {
      background: #5a9bd4;
      color: white;
    }
    tbody tr:nth-child(even) {
      background: #3a7bb8;
      color: white;
    }
    tbody tr:hover {
      background: #6ab6f0 !important;
      transition: background 0.25s ease;
    }
    td, th {
      padding: 14px 12px;
      border-right: 1px solid rgba(255,255,255,0.15);
    }
    td:last-child, th:last-child {
      border-right: none;
    }
    tr:last-child td {
      border-bottom: none;
    }
    .rank {
      font-weight: bold;
      font-size: 1.2rem;
      text-align: center;
    }
    @media (max-width: 1024px) {
      table { font-size: 0.9rem; }
      th, td { padding: 10px 8px; }
    }

        .password-crack-table-wrapper {
          margin: 1.5rem 0;
          overflow-x: auto;
        }
        table.password-crack-table {
          border-collapse: collapse;
          width: 100%;
          max-width: 100%;
          font-size: 0.9rem;
          background: #0b1020;
          color: #f5f7ff;
          border-radius: 8px;
          overflow: hidden;
          box-shadow: 0 0 0 1px rgba(255,255,255,0.04), 0 10px 30px rgba(0,0,0,0.4);
        }
        .password-crack-table thead {
          background: linear-gradient(90deg, #182848, #4b6cb7);
        }
        .password-crack-table th,
        .password-crack-table td {
          padding: 0.6rem 0.75rem;
          border: 1px solid rgba(255,255,255,0.07);
          vertical-align: top;
        }
        .password-crack-table th {
          text-align: left;
          font-weight: 600;
          white-space: nowrap;
        }
        .password-crack-table tbody tr:nth-child(odd) {
          background: rgba(255,255,255,0.02);
        }
        .password-crack-table tbody tr:nth-child(even) {
          background: rgba(255,255,255,0.06);
        }
        .pw-weak {
          background: rgba(255, 99, 71, 0.12);
        }
        .pw-strong {
          background: rgba(46, 204, 113, 0.12);
        }
        .pw-label {
          font-family: monospace;
          font-weight: 600;
        }
        .pw-note {
          font-size: 0.8rem;
          color: #c9d2ff;
        }
        .mfa-callout {
          margin-top: 1.5rem;
          padding: 1rem 1.1rem;
          border-radius: 8px;
          background: rgba(0, 173, 181, 0.06);
          border: 1px solid rgba(0, 173, 181, 0.6);
        }
        .mfa-callout h3 {
          margin-top: 0;
          margin-bottom: 0.4rem;
        }
        .mfa-callout ul {
          margin: 0.4rem 0 0.2rem 1.15rem;
        }
        .mfa-callout li {
          margin-bottom: 0.2rem;
        }
      </style>

      <div class="password-crack-table-wrapper">
        <table class="password-crack-table">
          <thead>
            <tr>
              <th>Password<br><span style="font-size:0.75rem; opacity:0.85;">(example only)</span></th>
              <th>SHA‑256 hash (first 16 hex chars)</th>
              <th>Approx. search space</th>
              <th>Brute‑force time – classical attacker<br><span style="font-size:0.75rem; opacity:0.85;">(10<sup>12</sup> guesses/sec)</span></th>
              <th>Brute‑force time – quantum attacker<br><span style="font-size:0.75rem; opacity:0.85;">(10<sup>18</sup> "effective" guesses/sec with Grover)</span></th>
            </tr>
          </thead>
          <tbody>
            <tr class="pw-weak">
              <td>
                <div class="pw-label">123456</div>
                <div class="pw-note">6 digits, only numbers</div>
              </td>
              <td>8d969eef6ecad3c2…</td>
              <td>10<sup>6</sup> ≈ 1,000,000</td>
              <td>≈ 10<sup>-6</sup> s (microseconds)</td>
              <td>Effectively instant</td>
            </tr>
            <tr class="pw-weak">
              <td>
                <div class="pw-label">password</div>
                <div class="pw-note">8 lower‑case letters</div>
              </td>
              <td>5e884898da280471…</td>
              <td>26<sup>8</sup> ≈ 2×10<sup>11</sup></td>
              <td>≈ 200 seconds (minutes)</td>
              <td>Grover over full space makes it even easier – effectively trivial</td>
            </tr>
            <tr>
              <td>
                <div class="pw-label">correcthorsebatterystaple</div>
                <div class="pw-note">~25 lower‑case; if chosen from 10<sup>4</sup> words<br>and 4‑word combos ⇒ ~10<sup>16</sup> possibilities</div>
              </td>
              <td>cbe6beb26479b568…</td>
              <td>≈ 10<sup>16</sup> (for a simple wordlist model)</td>
              <td>≈ 10<sup>4</sup> s ≈ a few hours<br>with a strong classical rig and very good wordlist</td>
              <td>Grover‑style speedup over 10<sup>16</sup> gives √10<sup>16</sup>=10<sup>8</sup> steps.<br>At 10<sup>18</sup> "effective" ops/s ⇒ ~10<sup>-10</sup> s, but this<br>ignores huge practical overheads. Still: quantum helps.</td>
            </tr>
            <tr class="pw-strong">
              <td>
                <div class="pw-label">S7q!vP9$Lm@2</div>
                <div class="pw-note">12 chars, ~72‑char alphabet<br>(upper/lower/digits/symbols)</div>
              </td>
              <td>(example) 4f9c2b1a7d8e6c5b…</td>
              <td>≈ 72<sup>12</sup> ≈ 4×10<sup>22</sup></td>
              <td>4×10<sup>10</sup> seconds ≈ 1,200+ years</td>
              <td>Grover reduces work to √4×10<sup>22</sup> ≈ 2×10<sup>11</sup> steps.<br>At 10<sup>18</sup>/s ⇒ ≈ 2×10<sup>-7</sup> s in the toy model,<br>but building such a fault‑tolerant quantum machine for real‑world
hash cracking is far beyond current tech.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p style="font-size:0.85rem; opacity:0.9; margin-top:0.4rem;">
        Assumptions are deliberately aggressive in favor of the attacker and
        ignore I/O, memory, and protocol defenses; they’re meant as back‑of‑the‑envelope
        illustrations, not operational guarantees. Also, SHA‑256 is used here in
        isolation; real systems should wrap it in slow, memory‑hard KDFs such as
        bcrypt, scrypt, or Argon2.
      </p>

      <div class="mfa-callout">
        <h3>Why MFA (multi‑factor authentication) still matters</h3>
        <p>Passwords—no matter how long—are only <em>one</em> factor: something you know. MFA adds at least one extra, independent factor, such as:</p>
        <ul>
          <li><strong>Something you have:</strong> a hardware security key (FIDO2/U2F), phone‑based OTP app, or smart card.</li>
          <li><strong>Something you are:</strong> biometrics like fingerprint or face unlock (ideally used as a local unlock for a hardware token, not sent to servers).</li>
        </ul>
        <p>Even if an attacker fully recovers your password hash and somehow inverts it, they still need to satisfy the other factor in real time. Concretely, MFA helps block:</p>
        <ul>
          <li><strong>Password database leaks:</strong> A stolen hash alone won’t log in without your second factor.</li>
          <li><strong>Credential stuffing:</strong> Re‑used passwords sprayed across many sites are far less useful when those sites enforce MFA.</li>
          <li><strong>Quantum‑assisted guessing:</strong> If powerful quantum machines eventually make certain brute‑force attacks cheaper, MFA still forces the attacker to compromise a device or biometric, not just a string.</li>
        </ul>
        <p>In practice, combining <strong>a strong, unique password</strong> (or passphrase) with <strong>hardware‑token‑based MFA</strong> gives you a large safety margin against both classical and foreseeable quantum brute‑force attacks.</p>
      </div>
    </section>
    <!-- END: Added password cracking / MFA table and explanation -->

  </main>
  <script>
  // Auto-highlight the current page
  const current = location.pathname.split('/').pop() || 'index.html';
  document.querySelectorAll('.main-nav a').forEach(link => {
    const href = link.getAttribute('href').split('/').pop();
    if (href === current) link.classList.add('active');
  });

  // Mobile toggle (if you want it)
  document.querySelector('.nav-toggle')?.addEventListener('click', () => {
    document.querySelector('.main-nav').classList.toggle('open');
  });
</script>
</body>
</html>
